#import "ThryveCoreSdkLibrary.h"

@implementation ThryveCoreSdkLibrary

RCT_EXPORT_MODULE()

RCT_EXPORT_METHOD(getAccessToken
                  :(NSString* _Nonnull)appId
                  :(NSString* _Nonnull)appSecret
                  :(NSString* _Nullable)partnerUserId
                  :(NSString* _Nullable)language
                  :(RCTResponseSenderBlock)callback)
{
  self.connector = [self createInstance:appId :appSecret :partnerUserId :language];
  
  [self.connector getAccessTokenOnSuccess:^(NSString *accessToken)
  {
    callback(@[[NSString stringWithFormat: @"%@", accessToken]]);
  }
  onError:^(NSError *e)
  {
    callback(@[[NSString stringWithFormat: @"error in getting access token: %@", e.localizedDescription]]);
  }];
}

RCT_EXPORT_METHOD(getDataSourceUrl
                  :(RCTResponseSenderBlock)callback)
{
  if (self.connector != nil)
  {
    [self.connector getDataSourceUrlOnSuccess:^(NSString *dataSourceUrl, NSString *dataSourceUrlToken)
    {
        callback(@[[NSString stringWithFormat: @"%@", dataSourceUrl]]);
    }
    onError:^(NSError *e)
    {
        callback(@[[NSString stringWithFormat: @"error in getting data source url: %@", e.localizedDescription]]);
    }];
  }
}

RCT_EXPORT_METHOD(uploadDailyDynamicValue
                  :(int)typeId
                  :(NSString *)value
                  :(NSString *)date
                  :(int)valueType
                  :(RCTResponseSenderBlock)callback)
{
  if (self.connector != nil)
  {
    CustomerValue *data = [self createDailyData:typeId :value :date :valueType];
    
    [self.connector uploadDailyDynamicValueWithData:data onError:^(NSError * _Nonnull e)
    {
      callback(@[[NSString stringWithFormat: @"error in uploading daily value: %@", e.localizedDescription]]);
    }];
  }
}

RCT_EXPORT_METHOD(uploadConstantValue
                  :(int)typeId
                  :(NSString *)value
                  :(int)valueType
                  :(RCTResponseSenderBlock)callback)
{
  if (self.connector != nil)
  {
    CustomerValue *data = [self createConstantData:typeId :value :valueType];
    
    [self.connector uploadConstantValueWithData:data onError:^(NSError * _Nonnull e)
    {
      callback(@[[NSString stringWithFormat: @"error in uploading constant value: %@", e.localizedDescription]]);
    }];
  }
}

- (CustomerValue *)createDailyData:(int)typeId
                                  :(NSString *)value
                                  :(NSString *)date
                                  :(int)valueType
{
    NSDate* parsedDate = [self getDate:date];
    ValueType enumValue = [self getValueType:valueType];
    DataType *type = [[DataType alloc] init:typeId :enumValue :nil];
    CustomerPayload *payload = [[CustomerPayload alloc] initWithValue:value of:type on:parsedDate];
    
    NSArray<CustomerPayload *> *dataArray = [[NSArray alloc] initWithObjects:payload, nil];
    return [[CustomerValue alloc] initWithData:(dataArray)];
}

- (CustomerValue *)createConstantData:(int)typeId
                                     :(NSString *)value
                                     :(int)valueType
{
    ValueType enumValue = [self getValueType:valueType];
    DataType *type = [[DataType alloc] init:typeId :enumValue :nil];
    CustomerPayload *payload = [[CustomerPayload alloc] initWithValue:value of:type];
    
    NSArray<CustomerPayload *> *dataArray = [[NSArray alloc] initWithObjects:payload, nil];
    return [[CustomerValue alloc] initWithData:(dataArray)];
}

- (NSDate *)getDate:(NSString *)string
{
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    [dateFormatter setDateFormat:@"yyyy-MM-dd"];
    return [dateFormatter dateFromString:string];
}

- (ValueType)getValueType:(int)value
{
    ValueType valueType;
    switch (value)
    {
        case 0:
            valueType = ValueTypeDouble;
            break;
        case 1:
            valueType = ValueTypeLong;
            break;
        case 2:
            valueType = ValueTypeBoolean;
            break;
        case 3:
            valueType = ValueTypeDate;
            break;
        case 4:
            valueType = ValueTypeString;
            break;
        default:
            valueType = ValueTypeString;
            break;
    }
    return valueType;
}

/* Depending on which parameters were passed, different instances of the Connector Module will be initialised.
 Be sure to track which appId (especcially partnerUserId if you use it) you are providing, the acccessToken value depends on it. */
- (CoreConnector *)createInstance:(NSString* _Nonnull)appId
                                 :(NSString* _Nonnull)appSecret
                                 :(NSString* _Nullable)partnerUserId
                                 :(NSString* _Nullable)language
{
  return [[CoreConnector alloc] initWithAppId:appId appSecret:appSecret partnerUserId:partnerUserId language:language];
}

@end
